<!DOCTYPE html>
<HTML>
<!--#set var=TITLE value="sTCW Assembly Guide" -->
<!--#include virtual="../ssi/head.html" -->
<a name=top></a>
<!--#include virtual="../ssi/start2.html" -->

This document describes the TCW assembly process.
which is run via the <code>viewSingleTCW</code> interface or the script <code>execAssm.pl</code> using the parameter file 
<tt>projects/&lt;project-name&gt;/sTCW.cfg</tt>.
<p>
Note that TCW <i>cannot assemble raw RNA-seq reads</i>. Rather, assembly in TCW serves primarily the following purposes:
<ul>
	<li> Assemble ESTs.
	<li> Assemble multiple transcripts libraries with optional count data. 
	<li> Assemble transcript library(s) with optional count data with ESTs.  
</ul>

<h2>Contents</h2>
<ul>
	<li><a href="#demo">Assembly of the demo project</a>
	<li><a href="#translib">Transcript with counts and EST libraries</a>
	<li><a href="#names">Choosing Read Names</a>
	<li><a href="#stages">The Assembly Process</a>
	<li><a href="#params">Assembly Parameters</a>
	<li><a href="#suspect">Suspect Contigs</a>
	<li><a href="#snps">SNPs and Extras</a>
	<li><a href="#trouble">Trouble shooting</a>
</ul>

<a name=demo>
<h2>Assembly of the Demo Project</h2>

This demo uses the project <tt>demoAsm</tt>. The assembly process uses <tt>blast</tt> and <tt>cap3</tt> (see 
<a href="../Install.html" class="ext" target="_blank">Installation</a>).
 
<p>
<table cellspacing=0 cellpadding=0>
	<tr>
		<td width="65%" valign="top">
<p>
Start by running <code>runSingleTCW</code> and selecting project <tt>demoAsm</tt>, giving the
interface shown on the right.
<p>The project has two libraries, <tt>Illumina</tt> (an Illumina RNA-seq library from ginger) and <tt>Sanger</tt>( 
an EST Sanger library from ginger). The Illumina transcripts have read counts from two
count libraries, <tt>tip</tt> and <tt>zone</tt>, reflecting two different tissues of the rhizome. 

<p>
Press the <b>Load Libraries</b> button to load the project to the database.
<p> 
Then set <b>#CPUs</b> to the number of processors your machine can spare for the assembly
(one or two are sufficient for this project). 
<p>
Press <b>Instantiate</b> to start the assembly.
<p>
When done, it prints a summary (see below). 
		</td>
		<td width="35%" valign="top" style="padding-left:10px;">
			<a name="FIG1">
			<a href="img/runSingleTCWasm.png"><img src="img/runSingleTCWasm.png" width="450" border=1></a>
			<p>
		</td>
	</tr>
<table>		
<h4>Final assembly summary</h4>

The final summary shows several items. 
<br>104 contigs formed, of which 80 were singletons (one read). 
<br>The largest contig had between 21-50 reads; the longest was >5kb. 
<br>14 reads were buried, i.e., were contained in another read (or nearly so), hence could be ignored during assembly.

<pre>
>>>Assembly Statistics 27-Mar-16 19:31:29

	DATASET                  #SEQS                    #SINGLETONS              #BURIED
	Illumina                 112                      78 (69%)                 13 (11%)
	Sanger                   98                       7 (7%)                   1 (1%)

	Total reads:  210
	Total buried: 14  Initial buries: 14   Buried during assembly: 0

	Contig aligned sequence counts
	Counts     =2         3-5        6-10       11=20      21-50      51-100     101-1000   >1000
	#Contigs   6          12         4          1          1          0          0          0

	Contig lengths (bp)
	Length     1-100      101-500    501-1000   1001-2000  2001-3000  3001-4000  4001-5000  >5000
	#Contigs   0          60         19         21         2          1          0          1

	Total contigs:     104
	Contigs(>1 seq):    24
	  Single mate-pair: 5
	Singletons:         80

	Finished in  1m:40s
</pre>

<a name="translib">
<table width='100%'><tr><td align='left' >
<h2>Transcript with counts and EST libraries</h2>
</td><td align='right' valign='top' class='smtxt'><a href=#top>Go to top</a> </td></tr></table>
When assembling transcripts with counts and EST libraries, a resulting contig with one or more transcript sequences
and one or more ESTs will add the transcript counts and add the aligned EST.
<p>
<a name=names></a>
<table width='100%'><tr><td align='left' >
<h2>Choosing Read Names</h2>
</td><td align='right' valign='top' class='smtxt'><a href=#top>Go to top</a> </td></tr></table>


Using consistent and well-chosen read names makes data analysis much easier, and
is essential for some aspects of TCW.
<p> 
The name of the read is the string immediately following the ">" in the fasta file.
For example, if your fasta file contains the lines
<div class="codesec"><pre>
>ZM_BFa0001A01.f
AAGATCCGCCTCATTCACACCCCCATCTACCTAGCTAGCTAGTTTACCAAAAAAAAATCTGGCCACA
GGGATGCGGTGGCGGCTGCAGCCGGCGCCGGCGCCGACGCTGCTCCTCGTCCTGCTGGTG
>ZM_BFa0001A01.r
AAAAAGCAAAATACAAACCAAGCTCCAGTTCCAATACATTACTCTAGCACAAGCTTTCAG
CACATTACAAAGTAGGAACCAAGACCACCCAAGCTCCAATCACACTACAATTCATCACCA
</pre></div>
then the two read names are <tt>ZM_BFa0001A01.f</tt> and <tt>ZM_BFa0001A01.r</tt>.
<p>
Naming guidelines:
<ul>
<li><b>length/characters:</b> Keep read names under 25 characters, using only letters, numbers, and underscores.
<li><b>uniqueness:</b> No two reads in a TCW database may have the same name. 
<li><b>prefixes:</b> Use the library name as the read prefix (e.g. <tt>ZM_BFa</tt> in this example). <br>
	This makes it much easier to study the assembled contigs where different
	libraries are mixed up. 
<li>For 454 data, the names are meaningless to the typical user, hence, the reads should be
  renamed with the library name followed by consecutive numbers.
<li><b>mate-pair suffixes:</b> If your read contain 5'/3' mate pairs, indicate 
this with suffixes (e.g. ".r", ".f" in this example). <i>The suffixes must be absolutely
consistent within a library</i>. If some read have ".r", while others have just "r", or
if some have ".r" meaning 3', while for others it means 5', then TCW cannot use the mate pair
information to improve the assembly.
</ul>

<p>
<a name=stages></a>
<table width='100%'><tr><td align='left' >
<h2>The Assembly Process</h2>
</td><td align='right' valign='top' class='smtxt'><a href=#top>Go to top</a> </td></tr></table>

Following are the main stages of TCW assembly, organized by their headings
which print to the screen. The sample durations
are for a 700k read assembly using 6, 2.4 Ghz CPUs and the default settings.


<table cellpadding=5 border=1>
	<tr>
		<td >Section Heading</td><td width='500'>What TCW is doing</td><td>Sample duration</td>
	</tr>
	<tr>
		<td valign='top'>&gt;&gt;&gt;Delete previous assembly</td>
		<td>There was a previous assembly of the same name, which you have selected to delete and
			start over. This can take a while for big projects!!</td><td>2h</td>
	</tr>
	<tr>
		<td valign='top'>&gt;&gt;&gt;Initial bury alignment</td>
		<td>TCW sets aside ("buries") reads which are nearly identical to another read, in order to reduce 
			redundant assembly effort. It runs a "self-blast" of all the reads against
			each other, using Megablast. It then parses the output and saves the buries to the database. </td><td>1h 10m</td>
	</tr>
	<tr>
		<td valign='top'>&gt;&gt;&gt;Compute cliques</td>
		<td>A clique is a special type of cluster<sup>1</sup>. TCW groups the reads into cliques and builds the
			initial contigs from them. To do this it again runs Megablast of the reads against
			each other, this time using only the non-buried reads. </td><td>1h 10m</td>
	</tr>
	<tr>
		<td valign='top'>&gt;&gt;&gt;Clique assembly</td>
		<td>Each clique is given to cap3 to assemble. Any leftover read are made into singleton "contigs".</td><td>2h</td>
	</tr>
	<tr>
		<td valign='top'>&gt;&gt;&gt;Clique cap buries</td>
		<td>The initial contigs from clique assembly are now analyzed for additional reads to bury. Any
			read lying in a region of 5x or greater coverage may be "cap-buried" in another read whose
			span in the contig is close enough. This is controlled by sTCW.cfg parameters CAP_BURY_MIN_DEPTH
			and CAP_BURY_MAX_HANG. For a large project, often over 50% of the clones will be buried
			by the end of this stage. </td><td>10m</td>
	</tr>
	<tr>
		<td valign='top'>&gt;&gt;&gt;Contig merge rounds</td>
		<td>Now TCW goes through the contig merge rounds specified by the "TC"<sup>2</sup> parameters in sTCW.cfg. For
			each round it writes out the current contig consensus sequences, blasts them against each
			other, and attempts to merge each overlapping pair. </td><td>9h</td>
	</tr>
	<tr>
		<td valign='top'>&gt;&gt;&gt;Finalize contigs</td>
		<td> Mate-pair contigs are joined together by N's. All buried reads are collected and assigned to 
			their correct final contig. Each read is re-aligned to the consensus sequence of its contig, 
			and the SNPs and extras are identified. Suspect contigs are flagged.</td><td>1h 10m</td>
	</tr>
</table>
<sup>1</sup> In a clique, each read must have an overlap with all reads in the clique.
<br><sup>2</sup> In a TC (transitive closure), each contig must have an overlap with at least one contig in the TC.


<a name=params></a>
<table width='100%'><tr><td align='left' >
<h2>Assembly Parameters</h2>
</td><td align='right' valign='top' class='smtxt'><a href=#top>Go to top</a></td></tr></table>

Note, the default parameters have been extensively tested and you will probably not want to change them.
Most of the parameters for assembly are available for change through the runSingleTCW interface (press
the <b>Options</b> button in the Assembly section); however, a few listed below 
(including those for calculating SNPs) would
 have to be set by hand in sTCW.cfg. The "Help" button on the runSingleTCW interface also 
describes the parameters.
<p>
Below is the full list of parameters and their defaults. 
All parameter names are case-insensitive. Note, the mySQL parameters are read from the HOSTS.cfg file.
<p>
<table border=1 cellpadding=4>
	<tr>
		<td><i>Parameter</i></td><td><i>Values</i></td><td><i>Default</i></td>
		<td width='500'>Description</td>
	</tr>
	


	<tr>
		<td class='emph' colspan='3'  style="padding:10px;">Burying</td>
		<td>Parameters related to burying of read for efficiency</td>
	</tr>

	<tr>
		<td>BURY_BLAST_EVAL</td><td>1e-NN</td><td>1e-100</td>
		<td>E-value for the initial bury blast.</td>
	</tr>
	<tr>
		<td>BURY_BLAST_IDENTITY</td><td>percent</td><td>99</td>
		<td>%Identity (-p) for the initial bury blast.</td>
	</tr>

	<tr>
		<td>BURY_BLAST_PARAMS</td><td>string</td><td>-FF </td>
		<td>Additional parameters for the initial bury blast.</td>
	</tr>

	<tr>
		<td>CAP_BURY_MIN_DEPTH</td><td>number</td><td>5</td>
		<td>Minimum coverage depth before an read may be buried.</td>
	</tr>
	<tr>
		<td>CAP_BURY_MAX_HANG</td><td>number</td><td>10</td>
		<td>Maximum overhang for burying read<sup>a</sup>.</td>
	</tr>

	<tr>
		<td>DO_INITIAL_BURY</td><td>1,0</td><td>1</td>
		<td>If set to 0, skip the initial burying of reads.</td>
	</tr>
	<tr>
		<td>DO_CAP_BURY</td><td>1,0</td><td>1</td>
		<td>If set to 0, do not bury reads based on cap3 assemblies.</td>
	</tr>
	<tr>
		<td>MIN_UNBURIED</td><td>number</td><td>0</td>
		<td>Preserve at least this many non-buried reads during the initial bury.</td>
	</tr>
	<tr>
		<td >RECAP_ARGS</td><td>string</td><td>-p&nbsp;70&nbsp;-y&nbsp;70&nbsp;-b&nbsp;80<br>-o&nbsp;49&nbsp;-t&nbsp;10000</td>
		<td>Arguments for re-capping after removing buried.<sup>b</sup></td>
	</tr>

	

	<tr>
		<td class='emph' colspan='3'  style="padding:10px;">Initial contigs</td>
		<td>Parameters for forming the initial contigs</td>
	</tr>
	<tr>
		<td>CLIQUE</td><td>3 numbers</td><td>100 98 20</td>
		<td>Minimal overlap, minimal %identity, maximal overhang<sup>a</sup>, respectively. 
        <br>Used for clique clustering.</td>
	</tr>
	<tr>
		<td>CLIQUE_BLAST_EVAL</td><td>e-value</td><td>1e-20</td>
		<td>E-value for Megablast used to form cliques.</td>
	</tr>
	<tr>
		<td>CLIQUE_BLAST_PARAMS</td><td>string</td><td> -FF</td>
		<td>Additional parameters for Megablast used to form cliques.</td>
	</tr>
	<tr>
		<td >SELF_JOIN</td><td>3 numbers</td><td>50 96 30</td>
		<td>Minimal overlap, minimal %identity, maximal overhang<sup>a</sup>, respectively.
      <br>Used to form a contig from overlapping 5' and 3' mate pair.</td>
	</tr>


	<tr>
		<td class='emph' colspan='3'  style="padding:10px;">Merging</td>
		<td>Parameters for the incremental contig merges</td>
	</tr>
	<tr>
		<td>CAP_ARGS</td><td>string</td><td>-p&nbsp;85&nbsp;-y&nbsp;70&nbsp;-b&nbsp;80<br>-o&nbsp;49&nbsp;-t&nbsp;10000</td>
		<td>Parameters for running cap3 (also used for assembling cliques).</td>
	</tr>

	<tr>
		<td>HEURISTICS</td><td>1,0</td><td>1</td>
		<td>Apply the heuristic rules for validation of contig merges (see publication; only affects
			mate-pairs).</td>
	</tr>
	<tr>
		<td >TC1</td><td>3 numbers</td><td>200 98 20</td>
		<td>Minimal overlap, minimal %identity, maximal overhang<sup>a</sup>, respectively. 
      <br>Used for first contig merge round.</td>
	</tr>
	<tr>
		<td >TC2</td><td>3 numbers</td><td>150 97 20</td>
		<td>Parameters for second contig merge round (same format as TC1).</td>
	</tr>
	<tr>
		<td >TC3</td><td>3 numbers</td><td>100 97 20</td>
		<td>Parameters for third contig merge round (same format as TC1).</td>
	</tr>
	<tr>
		<td >TCN, N&gt;3 </td><td>3 numbers</td><td>&nbsp;</td>
		<td>Parameters for Nth contig merge round (same format as TC1). Any number of TC can be specified, 
			with sequential values of N.</td>
	</tr>
	<tr>
		<td >TC_BLAST_EVAL</td><td>e-value</td><td>1e-20</td>
		<td>E-value for blast overlaps during contig merge stages.</td>
	</tr>
	<tr>
		<td >TC_BLAST_PARAMS</td><td>string</td><td>-FF </td>
		<td>Additional parameters for blast overlaps during contig merge stages.</td>
	</tr>


	<tr>
		<td class='emph' colspan='3'  style="padding:10px;">SNPs</td>
		<td>Parameters for computing SNPs/Extras</td>
	</tr>

	<tr>
		<td >EXTRA_CONFIRM</td><td>number</td><td>2</td>
		<td>Minimum number of occurrences of an extra base to lead to insertion of a pad in the consensus.</td>
	</tr>
	<tr>
		<td >EXTRA_SCORE</td><td>number</td><td>.001</td>
		<td>In addition to EXTRA_CONFIRM, a probabilistic score is also computed for each extra, which helps
		prevent excessive adding of pads in contigs of varying depth. This variable sets the maximum score. </td>
	</tr>
	<tr>
		<td >EXTRA_RATE</td><td>number</td><td>.005</td>
		<td>The rate of insertion of spurious bases by the sequencer. If this is not set in the PAVE.cfg, 
			then TCW will estimate the rate by using the contigs arising from the cliques. </td>
	</tr>

	<tr>
		<td >SNP_CONFIRM</td><td>number</td><td>2</td>
		<td>Minimum number of occurrences of a base substitution to be labeled as SNP.</td>
	</tr>
	<tr>
		<td >SNP_SCORE</td><td>number</td><td>.001</td>
		<td>In addition to SNP_CONFIRM, a probabilistic score is also computed for each snp, which helps
		control false positives in contigs of varying depth. This variable sets the maximum score. </td>
	</tr>
	<tr>
		<td >BASECALL_ERROR_RATE</td><td>number</td><td>.005</td>
		<td>The rate of basecall error by the sequencer. If this is not set in the sTCW.cfg, 
			then sTCW will estimate the rate by using the contigs arising from the cliques. </td>
	</tr>

	<tr>
		<td>IGNORE_HPOLY</td><td>number</td><td>3</td>
		<td>Length of homopolymer required for a putative SNP to be ignored, not counting the 
				base in question. (set to 0 to keep all SNPs). Note: Variable 
			homopolymer length is a common source of error in 454 sequences.</td>
	</tr>
	<tr>
		<td>INDEL_CONFIRM</td><td>number</td><td>2</td>
		<td>Number of confirming gaps required to count an indel.</td>
	</tr>

	<tr>
		<td >UNBURY_SNP</td><td>1,0</td><td>1</td>
		<td>If set, then at least two read containing each SNP will be unburied for ease of viewing.</td>
	</tr>

	<tr>
		<td class='emph' colspan='3'  style="padding:10px;">Miscellaneous</td>
		<td>Additional parameters</td>
	</tr>
	<tr>
		<td>CPUs</td><td>number</td><td>1</td>
		<td>Number of system processors to use in computations.</td>
	</tr>
	<tr>
		<td>DEBUG</td><td>0,1</td><td>0</td>
		<td>Set to 1 to debug certain errors, e.g. failures of cap3. Preserves all intermediate 
			assembly stages, creating a large number of files and using considerable disk space.</td>
	</tr>
	<tr>
		<td>SKIP_ASSEMBLY</td><td>number</td><td>0</td>
		<td>Don't do any assembly of the library sequences, just make a final contig from each one. </td>
	</tr>
	<tr>
		<td>USE_TRANS_NAME</td><td>number</td><td>0</td>
		<td>Use the given transcript names rather than renaming (only with SKIP_ASSEMBLY=1)</td>
	</tr>


</table>
<div class="hang"><sup>a</sup> Overhang measures non-aligning bases at one end of an alignment, 
			which can occur due to trimming errors. 
</div>
<div class="hang"><sup>b</sup> Contigs are re-capped (i.e., reassembled in cap3) after some reads
 have been buried, to ensure that they still assemble. 
</div>

<p>
<a name=suspect></a>
<table width='100%'><tr><td align='left' >
<h2>Suspect contigs</h2>
</td><td align='right' valign='top' class='smtxt'><a href=#top>Go to top</a> </td></tr></table>

At the end of the assembly, TCW scans the contigs for possible chimerics. These are contigs which
appear to be held together by just one read, without which the contig would separate into two. 
Such an read could be chimeric, i.e., composed of two different reads joined together, in which case
the contig also is incorrect. 
<p>
The suspect contigs are marked by a note of the form "suspect @clone" where "clone" is the name
of the suspected chimeric clone. These contigs can then be found and examined in viewSingleTCW by using
the "Basic Contig Search" using the "Search by Notes" option. 


<p>
<a name=snps></a>
<table width='100%'><tr><td align='left' >
<h2>Calculation of SNPs and extras</h2>
</td><td align='right' valign='top' class='smtxt'><a href=#top>Go to top</a> </td></tr></table>

A SNP is possible when one or more read have a different base at some location than is found in the consensus. 
However, basecalling error can lead to many false positives, so TCW applies two screens to the possible
SNPs. First, at least two reads must contain the SNP (you can change this with the SNP_CONFIRM parameter).  
<p>
Also, a probability score is applied. The probability ('p-value') is computed using a binomial score based on the number of
confirming reads, the depth of the contig at that base, and the estimated basecall error rate. 
The error rate is estimated from mismatches seen in the clique assembly, or it can be
set using BASECALL_ERROR_RATE. The p-value threshold can also be set using SNP_SCORE.
<p>
When there are extra bases in some reads which are not in the consensus sequence
generated by cap3, TCW uses another probability score to determine whether to regard the extras as "real" 
and add a pad character (*) to the consensus. The score is computed in the same way as for SNPs, and uses
the config parameters EXTRA_CONFIRM, EXTRA_RATE, EXTRA_SCORE. Extras not determined to be real are
stored in the database and shown in the UI.

<a name=trouble></a>
<h3>Trouble Shooting</h3>
<ul>
<li>Blast fails. 

If you are doing a large assembly (1M or more reads) on a 32-bit computer, then megaBlast may run out of memory. 
Switch to a 64-bit platform, with the 64-bit version of megaBlast (very important!). 
<p>

*** System call failed:  Thu Feb 12 14:19:11 2009
*** /opt/bin/cap3 tmp/tmp_14425 -p 80 -y 70 -b 80 -f 8 -o 49 -t 10000 > /dev/null
*** Call ended with signal 65535: Cannot allocate memory

*** (TCW recovered and will continue assembly)
</pre-->
<p>
If the errors are rare then the assembly should still succeed. If many errors are
seen, then it should be investigated. 
To do this, stop the assembly and restart it with DEBUG=1 in sTCW.cfg (it does not
have to be restarted from the beginning.)
When the failure message appears again, copy the command that failed and
try to run it manually to see why it is failing. 
<p-->
<li>CAP3 fails. If you get an <tt>"java.io.IOException: Cannot run program</tt>", then the supplied CAP3 is
not compatible with your OS. Go to <a href="http://seq.cs.iastate.edu/cap3.html" class="ext" target="_blank">seq.cs.iastate.edu/cap3.html</a>,
and download a CAP3 compatible with your systems and put it in <tt>/external/CAP3</tt> or <tt>/external_osx/CAP3</tt> for Linux or Mac, respectively.

<p>
<li>Other assembly interruptions
<p>
An assembly lasting multiple days can be interrupted for numerous reasons, e.g. running
out of memory, losing connection to the database, or having the system reboot. In most
cases this is not a problem and the assembly can be restarted to resume where it left
off. It will check its database for consistency, and if the assembly continues successfully, 
then it should be fine, while if there are
errors then it should be restarted from the beginning.
<p>
If the assembly crashes, it will usually write the Java exception error into a 
file pave.fatalerror. This is information that we can use to debug and fix the problem.
</ul>

<h4>For assembly, the database must support Innodb tables</h4>

TCW checks this using the "show engines" command in MySQL. If the Innodb
engine is not listed as supported, this error is shown; however, you can
still perform all TCW functions except for assembly. 
<p>
The most common cause of this problem is a mismatch in the innodb log
file size. The MySQL error log will contain messages like 
<div class="codesec"><pre>
InnoDB: Error: log file ./ib_logfile0 is of different size 0 5242880 bytes
InnoDB: than specified in the .cnf file 0 104857600 bytes!
</pre></div>
Solution is to delete this log file and restart MySQL.

<h4>Doing an assembly, the database is very slow</h4>

The default parameters of MySQL are not suitable for large high-performance
databases. Especially, the <tt>innodb_buffer_pool_size</tt> must be increased. 
100M is sufficient for one large project, but for many large projects it should
be 1G at minimum. For more see <br>
<a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-buffer-pool.html" class="ext" target="_blank">
http://dev.mysql.com/doc/refman/5.0/en/innodb-buffer-pool.html</a>.
Note, this only affects usage during an assembly, when InnoDB tables are used.
<br>
<!--#include virtual="../ssi/end.html" -->
</HTML>
